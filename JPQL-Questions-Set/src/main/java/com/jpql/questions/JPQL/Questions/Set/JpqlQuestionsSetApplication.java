package com.jpql.questions.JPQL.Questions.Set;

import com.jpql.questions.JPQL.Questions.Set.entities.Book;
import com.jpql.questions.JPQL.Questions.Set.entities.Library;
import com.jpql.questions.JPQL.Questions.Set.entities.Member;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import jakarta.persistence.TypedQuery;
import org.hibernate.Session;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.transaction.support.TransactionTemplate;

import java.time.LocalDate;
import java.util.List;

@SpringBootApplication
public class JpqlQuestionsSetApplication {

	@Autowired
	TransactionTemplate transactionTemplate;

	public static void main(String[] args) {
		SpringApplication.run(JpqlQuestionsSetApplication.class, args);
	}

	@Bean
	public CommandLineRunner commandLineRunner(EntityManager entityManager) {
		return runner -> {
			func10(entityManager);
		};
	}

	/*
	List all books borrowed by a specific member.
	* */
	private void func1(EntityManager entityManager) {
		String jpql = "SELECT b \n" +
					"FROM Book b \n" +
					"JOIN b.borrowTransactions bt \n" +
					"JOIN FETCH b.library \n" +
					"WHERE bt.member.id = :memberId\n";    //Only 1 query generated by hibernate if we use fetch = FetchType.LAZY on library field in Book
		//Otherwise we got 2 queries.
		String jpql2 = """
				SELECT b FROM Book b JOIN BorrowTransaction bt ON b.id = bt.book.id
				JOIN Member m ON bt.member.id = m.id WHERE m.id = :memberId
				""";
		TypedQuery<Book> query = entityManager.createQuery(jpql2, Book.class);
		query.setParameter("memberId", 1);
		List<Book> books = query.getResultList();
		System.out.println("Total Books = " + books.size());
	}

	/*
	List all books borrowed between specific dates.
	* */
	private void func2(EntityManager entityManager) {
		String jpql = """
				SELECT b FROM Book b
				JOIN BorrowTransaction bt ON b.id = bt.book.id
				WHERE bt.borrowDate BETWEEN :startDate and :endDate
				ORDER BY bt.borrowDate
				"""; //BETWEEN operator is inclusive
		TypedQuery<Book> query = entityManager.createQuery(jpql, Book.class);
		query.setParameter("startDate", LocalDate.of(2024, 12, 1));
		query.setParameter("endDate", LocalDate.of(2024, 12, 10));
		List<Book> books = query.getResultList();
		System.out.println("Total Books = " + books.size());
	}

	/*
	Find libraries with the most borrowed books.
	* */

	private void func3(EntityManager entityManager) {

		String jpql = """
				SELECT l.name, COUNT(bt.id) AS borrowCount
				FROM Library l
				JOIN l.members m
				JOIN m.borrowTransactions bt
				GROUP BY l.name
				ORDER BY borrowCount DESC
				""";

		String jpql2= """
				SELECT l.name, COUNT(bt.id) AS count
				FROM Library l
				JOIN Member m ON l.id = m.library.id
				JOIN BorrowTransaction bt ON
				m.id = bt.member.id
				GROUP BY l.name
				ORDER BY count DESC
				""";
		TypedQuery<Object[]> query = entityManager.createQuery(jpql2, Object[].class);
		List<Object[]> resultList = query.getResultList();

		for (Object[] result : resultList) {
			String libraryName = (String) result[0];  // First element is library name
			Long borrowCount = (Long) result[1];      // Second element is borrow count
			System.out.println("Library Name: " + libraryName + ", Borrow Count: " + borrowCount);
		}
	}

	/*
	Get all members who have borrowed books from a specific genre.
	**/
	private void func4(EntityManager entityManager) {

		/*
		SQL Query tested in MYSQL:
			SELECT m.* FROM member m
			JOIN borrow_transaction bt ON m.id = bt.member_id
			JOIN book b ON b.id = bt.book_id
			WHERE b.genre = 'Fiction' ORDER BY m.id;

			SELECT DISTINCT m.* FROM member m
			JOIN borrow_transaction bt ON m.id = bt.member_id
			JOIN book b ON b.id = bt.book_id
			WHERE b.genre = 'Fiction' ORDER BY m.id;

			These queries are very helpful in understanding the purpose of DISTINCT keyword
		* */

		String jpql = """
				SELECT m
				FROM Member m
				JOIN m.borrowTransactions bt
				JOIN bt.book b
				WHERE b.genre = :genre
				""";
		TypedQuery<Object[]> query = entityManager.createQuery(jpql, Object[].class);
		query.setParameter("genre", "Fiction");  // Example genre
		List<Object[]> members = query.getResultList();
		System.out.println(members.size());


		String jpql2 = """
				SELECT m
				FROM Member m
				JOIN m.borrowTransactions bt
				JOIN bt.book b
				WHERE b.genre = :genre
				""";
		TypedQuery<Member> query2 = entityManager.createQuery(jpql2, Member.class);
		query2.setParameter("genre", "Fiction");  // Example genre
		List<Member> members2 = query2.getResultList();
		System.out.println(members2.size());
	}

	/*
	** INTERESTING QUESTION **
	* Why do these two identical JPQL queries in Hibernate return different result counts?
	* https://stackoverflow.com/questions/79305294/why-do-these-two-identical-jpql-queries-in-hibernate-return-different-result-cou/79305701#79305701
	* */
	private void func5(EntityManager entityManager) {
		String jpqlWithObjectType = """
                    SELECT l\s
                    FROM Library l
                    JOIN Member m
                    ON m.library.id = l.id\s
                    """;
		TypedQuery<Object[]> query1 = entityManager.createQuery(jpqlWithObjectType, Object[].class);
		List<Object[]> libraries1 = query1.getResultList();
		System.out.println(libraries1.size());

		String jpqlWithLibraryType = """
                    SELECT l\s
                    FROM Library l
                    JOIN Member m
                    ON m.library.id = l.id\s
                    """;
		TypedQuery<Library> query2 = entityManager.createQuery(jpqlWithLibraryType, Library.class);
		List<Library> libraries2 = query2.getResultList();
		System.out.println(libraries2.size());
	}

	/*
	Check if the object is in the first-level cache
	* */

	private void func6(EntityManager entityManager) {
		Session session = entityManager.unwrap(Session.class);
		Member member = session.get(Member.class, 2);
		if (session.contains(member)) {
			System.out.println("The member object is in the first-level cache.");
		} else {
			System.out.println("The member object was not in the first-level cache.");
		}
	}

	/*
	List all overdue books and their borrowers.
	* */

	private void func7(EntityManager entityManager) {
		String jpql = """
				SELECT b.title, m.firstName, m.lastName FROM BorrowTransaction bt
				JOIN Book b ON bt.book.id = b.id
				JOIN Member m ON bt.member.id = m.id
				WHERE bt.returnDate < CURRENT_DATE OR bt.returnDate IS NULL
				"""; //BETWEEN operator is inclusive
		TypedQuery<Object[]> query = entityManager.createQuery(jpql, Object[].class);
		List<Object[]> objects = query.getResultList();
		System.out.println("Total Books = " + objects.size());

		for (Object[] object : objects) {
			String title = (String) object[0];  // Book title
			String firstName = (String) object[1];  // Member first name
			String lastName = (String) object[2];  // Member last name
			System.out.println("Overdue Book: " + title + ", Borrower: " + firstName + " " + lastName);
		}
	}

	/*
	Update Overdue Fines.
	* */
	public void func8(EntityManager entityManager) {
		this.transactionTemplate.execute(transactionStatus -> {
			String jpql = """
            UPDATE BorrowTransaction bt
            SET bt.fineAmount = (DATEDIFF(CURRENT_DATE, bt.returnDate) * 10)
            WHERE bt.isReturned = false AND bt.returnDate < CURRENT_DATE
        """;

			Query query = entityManager.createQuery(jpql);
			int updatedCount = query.executeUpdate();  // Returns the number of updated rows
			System.out.println("Number of overdue fines updated: " + updatedCount);
			return null;
		});
	}

	/*
	Get the most popular book in the library.
	* */

	private void func9(EntityManager entityManager) {
		String jpql = """
				SELECT b.title as bookTitle, COUNT(*) FROM BorrowTransaction bt
				JOIN bt.book b
				GROUP BY b.id
				ORDER BY bookTitle DESC
				""";
		TypedQuery<Object[]> query = entityManager.createQuery(jpql, Object[].class);
		List<Object[]> objects = query.getResultList();
		System.out.println("Total Books = " + objects.size());

		for (Object[] object : objects) {
			String bookTitle = (String) object[0];
			Long count = (Long) object[1];
			System.out.println("Book: " + bookTitle + ", Count: " + count);
		}
	}

	/*
	Retrieve all authors whose books are available in more than one library.
	* */

	private void func10(EntityManager entityManager) {
		String jpql = """
				SELECT DISTINCT b.author FROM Book b
				JOIN b.library l
				GROUP BY b.author
				HAVING COUNT(DISTINCT l.id) > 1
				""";
		TypedQuery<Object[]> query = entityManager.createQuery(jpql, Object[].class);
		List<Object[]> objects = query.getResultList();
		System.out.println("Total Books = " + objects.size());

		for (Object[] object : objects) {
			String author = (String) object[0];
			System.out.println("Book Author: " + author);
		}
	}

}
